/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.mycompany.findvulnerability;

import com.opencsv.CSVWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.DirectoryNotEmptyException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import org.neo4j.driver.v1.Driver;
import org.neo4j.driver.v1.Record;
import org.neo4j.driver.v1.Session;
import org.neo4j.driver.v1.StatementResult;
import org.neo4j.driver.v1.Transaction;
import org.neo4j.driver.v1.TransactionWork;
import org.neo4j.driver.v1.Value;
import static org.neo4j.driver.v1.Values.parameters;

/**
 *
 * @author Fatemeh Saligheh
 */
public class XSS {
    
    final Driver driver;
    String fileName ;
    List<Record> target;
    public XSS(final Driver driver , String fileName) throws IOException{
        this.driver = driver;
        this.fileName = fileName;
        boolean Finalresult = false;
         
        
        
        File file = new File("xss.csv");
        FileWriter csvWriter1 = new FileWriter(file,true);
        CSVWriter csvWriter = new CSVWriter(csvWriter1);
        System.out.println("*********************************************************xss test**********************************************************");
        List<Record> source = FindRootXSS();
        List<Record> sink = findTarget();
        
        for(int i=0 ; i<source.size() & !source.isEmpty();i++){
            for(int j=0 ; j<sink.size() & !sink.isEmpty();j++){
                List<Record> path = TraversalXSS(source.get(i).values().get(0),sink.get(j).values().get(0)); 
                    if(!path.isEmpty()){
                        Finalresult = true;
                        
                        for(int z=1 ; z<path.get(0).values().get(1).size();z++){
                            Iterator<Value> values = path.get(0).values().get(1).get(z).asNode().values().iterator();
                            values.next();values.next();
                            Value val = values.next();
//                            System.out.println(val);
                            if(val.toString().indexOf("encodeForHTML") != -1 ? true : false){
                                Finalresult = false;
                            }else if(val.toString().indexOf("escapeHtml") != -1 ? true : false){
                                Finalresult = false;
                            }else if(val.toString().indexOf("htmlEscape") != -1 ? true : false){
                                Finalresult = false;
                            }
                        }
                    }                   
                   
                    
            }
        }
        
        
         if (Finalresult == true) {
            String[] list1 = {fileName, "true"};
            csvWriter.writeNext(list1);
        } else {
            String[] list1 = {fileName, "false"};
            csvWriter.writeNext(list1);
        }
        csvWriter.close();  
       
    }
    
    
    public List<Record> FindRootXSS(){
        
        
        try (Session session = driver.session()) {
                    StatementResult result = session.run("MATCH (t:nodes)-[]->(n:nodes)\n" +
                                                        "WHERE n.label=\"TYPE\" and n.code =~ \"HttpServletRequest\"\n" +
                                                        "MATCH (x:nodes)-[]->(y:nodes)\n" +
                                                        "where x=t and y.label=\"NAME\"\n" +
                                                        "RETURN y.code");
                    List<Record> resList = result.list();
//                    System.out.println(resList.get(0).values().get(0));
                    return resList;

        }
    }
    
    public List<Record> findTarget(){
        try (Session session = driver.session()) {
                    StatementResult result = session.run("MATCH (t:nodes)-[]->(n:nodes)\n" +
                                                        "WHERE n.label=\"TYPE\" and n.code =~ \"HttpServletResponse\"\n" +
                                                        "MATCH (x:nodes)-[]->(y:nodes)\n" +
                                                        "where x=t and y.label=\"NAME\"\n" +
                                                        "RETURN y.code");
                    List<Record> resList = result.list();
                    return resList;
        }
    }

    public List<Record> TraversalXSS (Value source, Value sink){
        String so = source.toString().replaceAll("\"", "");
        String si = sink.toString().replaceAll("\"", "");
        try (Session session = driver.session()) {
            StatementResult result = session.run("MATCH (cs:nodes),(ms:nodes), p = shortestPath((ms)-[*]->(cs))\n" +
                                                "where cs.code =~ \".*"+si+".getWriter().*\" AND ms.code =~ \".*"+so+".*\" AND cs.graph ='PDG-DATA' AND ms.graph ='PDG-DATA'\n" +
                                                "WITH p\n" +
                                                "WHERE length(p)> 1\n" +
                                                "RETURN p,nodes(p)");
            
            List<Record> resList = result.list();
            
            return resList;
        }
        
    }
    
    
    
}
